# The cling executable is only used to get the path to the library.
# This patch lets us remove the executable to save space.
diff --git a/tools/Jupyter/kernel/clingkernel.py b/tools/Jupyter/kernel/clingkernel.py
index befb193..81250e4 100644
--- a/tools/Jupyter/kernel/clingkernel.py
+++ b/tools/Jupyter/kernel/clingkernel.py
@@ -67,26 +67,12 @@ class ClingKernel(Kernel):
 
     def __init__(self, **kwargs):
         super(ClingKernel, self).__init__(**kwargs)
-        try:
-            whichCling = shutil.which('cling')
-        except AttributeError:
-            from distutils.spawn import find_executable
-            whichCling = find_executable('cling')
-        if whichCling:
-            clingInstDir = os.path.dirname(os.path.dirname(whichCling))
-            llvmResourceDir = clingInstDir
+        libFilename = "/usr/local/lib/libclingJupyter.so"
+        if os.access(libFilename, os.R_OK):
+            self.libclingJupyter = ctypes.CDLL(libFilename, mode = ctypes.RTLD_GLOBAL)
+            llvmResourceDir = '/usr/local'
         else:
-            raise RuntimeError('Cannot find cling in $PATH. No cling, no fun.')
-
-        for ext in ['so', 'dylib', 'dll']:
-            libFilename = clingInstDir + "/lib/libclingJupyter." + ext
-            if os.access(libFilename, os.R_OK):
-                self.libclingJupyter = ctypes.CDLL(clingInstDir + "/lib/libclingJupyter." + ext,
-                                                   mode = ctypes.RTLD_GLOBAL)
-                break
-
-        if not getattr(self, 'libclingJupyter', None):
-            raise RuntimeError('Cannot find ' + clingInstDir + '/lib/libclingJupyter.{so,dylib,dll}')
+            raise RuntimeError('Cannot find ' + libFilename)
 
         self.libclingJupyter.cling_create.restype = my_void_p
         self.libclingJupyter.cling_eval.restype = my_void_p
